---
title: "Oficina de webscraping de dados Legislativos com R e XML - Atividade 1"
author: "Leonardo Sangali Barone e Alexia Aslan"
date: "11-03-2016"
output: pdf_document
---

# Pacotes no R

Algumas das funções que vamos utilizar nesta atividade não estão na biblioteca básica do R. Temos, dessa forma, que começar instalando uma biblioteca chamada "XML". A biblioteca já está instalada nos computadores que vamos utilizar hoje. Porám, vamos refazer o processo de instalação para aprender um pouco mais. Execute o comando abaixo:

```{r}
#install.packages("XML")
```

Uma vez instalada a biblioteca, as funções não estão automaticamente disponíveis. Para torná-las disponíveis é preciso "chamar" a biblioteca. Vamos fazer isso com a biblioteca "XML". Execute o comando abaixo:

```{r}
library(XML)
```

Excelente! Já temos as funções que precisamos disponíveis na nossa sessão. Vamos utilizá-las logo mais.

# Atividade inicial - Pesquisa de Proposições na ALESP

## For loop e links com numeração de página

Vamos começar visitando o site da ALESP e entrar na ferramenta de pesquisa de proposições: http://www.al.sp.gov.br/alesp/pesquisa-proposicoes/
No site, vamos elaborar uma pesquisa qualquer que retorne uma quantidade de respostas que manualmente seria no mínimo ineficiente coletarmos.
Por exemplo, podemos pesquisa por todos os Projetos de Lei relacionados à palavra "merenda".

Na data deste tutorial, eram 747 documentos. O resultado, porém, está espalhado em 75 tabelas de 10 linhas.
Há 4 informações sobre os projetos: data, título (e número do projeto), autor e etapa.

Nossa primeira tarefa consiste em capturar estas informações. Vamos, no decorrer da atividade aprender bastante sobre R, objetos, estruturas de dados, loops e captura de tabelas em HTML

Vamos armazenar a URL em um objeto ("url_base", mas você pode dar qualquer nome que quiser).

```{r}
url_base <- "http://www.al.sp.gov.br/alesp/pesquisa-proposicoes/?direction=inicio&lastPage=0&currentPage=0&act=detalhe&idDocumento=&rowsPerPage=10&currentPageDetalhe=1&tpDocumento=&method=search&text=merenda&natureId=&legislativeNumber=&legislativeYear=&natureIdMainDoc=&anoDeExercicio=&legislativeNumberMainDoc=&legislativeYearMainDoc=&strInitialDate=&strFinalDate=&author=&supporter=&politicalPartyId=&tipoDocumento=&stageId=&strVotedInitialDate=&strVotedFinalDate=#"
```

Podemos ver que há muitas páginas de resultado para a palavra-chave que utilizamos. Nosso desafio é conseguir passar de forma eficiente por elas. Para isso, usaremos uma função essencial na programação, o "for loop".

Loops são processos iterativos e são extremamente úteis para instruir o computador a repetir uma tarefa por um número finito de vezes. Por exemplo, vamos começar "imprimindo" na tela os números de 1 a 9:

```{r}
for (i in 1:9) {
  print(i)
}
```
Simples, não? Vamos ler esta instrução da seguinte maneira: "para cada número i no conjunto que vai de 1 até 9 (essa é a parte no parênteses) imprimir o número i (instrução entre chaves)". E se quisermos imprimir o número i multiplicado por 9 (o que nos dá a tabuada do 7!!!), como devemos fazer?

```{r}
for (i in 1:9) {
  print(i * 7)
}
```

Tente agora construir um exemplo de loop que imprima na tela os números de 3 a 15 multiplicados por 10 como exerício.

Ótimo! Já temos alguma intuição sobre como loops funcionam. Será com eles que faremos a movimentação das páginas.
O que nos falta é uma função que nos permita juntar o texto básico do link ("baseurl") com os números das páginas.
Há mais de uma opção, mas aqui usaremos a função "gsub". 

Com a função "gsub" podemos substituir em objeto de texto por outro, de acordo com o critério especificado.
Os argumentos (o que vai entre os parenteses) da função é, em ordem, o termo a igualar, o que eu quero que coloque no lugar, onde eu quero que coloque.

Na prática, ela funciona da seguinte forma:

```{r}
onde_quero_substituir <- "quero substituir essa palavra"
o_que_procuro_para_susbtituir <- "palavra"
o_que_quero_substituir_por <- "batata"

texto_final <- gsub(o_que_procuro_para_susbtituir, o_que_quero_substituir_por, onde_quero_substituir)

print(texto_final)
```


Em primeiro lugar, vamos copiar o link do resultado da busca. Veja que o link contém diversas informações sobre a busca.
Em diversos casos essas informações são exatamente os parâmetros da busca que você realizou (nem sempre, porém - vamos aprender a identificar)!

Vamos fazer um teste: passemos para a página seguinte da busca e vamos ver o que muda no link.

Há muitas informações nesse link, basicamente todos os campos que poderiam ter sido especificados na busca são apresentados no link. Como preenchemos apenas com o termo ("merenda"), esse será o único parametro definido na URL ("text=merenda").

Algo também importante é identificar como as páginas mudando se manifestam na URL.
Lembra que clicamos para a página seguinte para notar o que havia ficado diferente? Descobrimos que na URL, o que varia ao clicar na próxima página é o "currentPage=0"





Em seguida, precisamos de uma estrutura que armazene 

```{r}
library(XML)

url_base <- "http://www.al.sp.gov.br/alesp/pesquisa-proposicoes/?direction=inicio&lastPage=0&currentPage=FRANGO&act=detalhe&idDocumento=&rowsPerPage=100&currentPageDetalhe=1&tpDocumento=&method=search&text=%E1gua&natureId=&legislativeNumber=&legislativeYear=&natureIdMainDoc=&anoDeExercicio=&legislativeNumberMainDoc=&legislativeYearMainDoc=&strInitialDate=&strFinalDate=&author=&supporter=&politicalPartyId=&tipoDocumento=&stageId=&strVotedInitialDate=&strVotedFinalDate="

dados <- data.frame()
for (i in 0:19){
  print(i)
  url <- gsub("FRANGO", i, url_base)
  tabela <- readHTMLTable(url)[[1]]
  dados <- rbind(dados, tabela)
}
```
